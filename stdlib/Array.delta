class Array<Element> {
    var bufferPointer: mutable Element*?;
    var size: uint;
    var capacity: uint;

    /// Initializes an empty array.
    init() {
        bufferPointer = null;
        size = 0;
        capacity = 0;
    }

    deinit() {
        free(cast<mutable void*?>(bufferPointer));
    }

    /// Returns the number of elements in the array.
    func size() -> uint {
        return size;
    }

    /// Returns true if the array has no elements, otherwise false
    func isEmpty() -> bool {
        return size == 0;
    }

    /// Returns the number of elements the array can store without allocating more memory.
    func capacity() -> uint {
        return capacity;
    }

    /// Returns the element at the given index.
    func [](index: uint) -> Element* {
        if (index >= size) {
            _indexOutOfBounds(index);
        }

        return bufferPointer! + index;
    }

    /// Returns the element at the given index.
    mutating func [](index: uint) -> mutable Element* {
        if (index >= size) {
            _indexOutOfBounds(index);
        }

        return bufferPointer! + index;
    }

    func first() -> Element* {
        if (size == 0) {
            _emptyArrayFirst();
        }

        return bufferPointer!;
    }

    func last() -> Element* {
        if (size == 0) {
            _emptyArrayLast();
        }

        return bufferPointer! + size;
    }

    func data() -> Element* {
        return bufferPointer!;
    }

    mutating func data() -> mutable Element* {
        return bufferPointer!;
    }

    /// Adds the given element to the end of the array.
    mutating func push(newElement: Element) {
        reserve(size + 1);
        *(bufferPointer! + size) = newElement;
        size++;
    }

    /// Ensures that the capacity is large enough to store the given number of elements.
    mutating func reserve(minimumCapacity: uint) {
        if (minimumCapacity > capacity) {
            if (capacity == 0) {
                capacity = 1;
            } else {
                capacity *= 2;
            }

            let newBufferPointer = cast<mutable Element*?>(malloc(sizeof(Element) * uint64(capacity)));

            for (let index in 0..size) {
                let source = bufferPointer! + index;
                let target = newBufferPointer! + index;
                *target = *source;
            }

            free(cast<mutable void*?>(bufferPointer));
            bufferPointer = newBufferPointer;
        }
    }

    /// Removes the first element from the array.
    /// Other elements are moved towards the beginning of the array by one index.
    mutating func removeFirst() {
        if (size == 0) {
            _emptyArrayRemoveFirst();
        }

        _removeAt(0);
    }

    /// Removes the last element from the array.
    mutating func removeLast() {
        if (size == 0) {
            _emptyArrayRemoveLast();
        }

        // TODO: Call deinitializer of removed element.
        size--;
    }

    /// Removes the element at the given index from the array.
    /// Elements following the removed element are moved towards the beginning of the array by one index.
    mutating func removeAt(index: uint) {
        if (index >= size) {
            _indexOutOfBounds(index);
        }

        _removeAt(index);
    }

    mutating func _removeAt(index: uint) {
        // TODO: Call deinitializer of removed element.

        for (let i in (index + 1)..size) {
            let source = bufferPointer! + i;
            let target = bufferPointer! + (i - 1);
            *target = *source;
        }

        size--;
    }

    func iterator() -> ArrayIterator<Element> {
        // TODO: When implicit initializers have been implemented, remove the ArrayRef() call below.
        return ArrayIterator(ArrayRef(this));
    }

    mutating func iterator() -> MutableArrayIterator<Element> {
        return MutableArrayIterator(this);
    }

    func _indexOutOfBounds(index: uint) {
        printf("Array index %d is out of bounds, size is %d\n", index, size());
        fatalError();
    }

    func _emptyArrayFirst() {
        printf("Called first() on empty Array\n");
        fatalError();
    }

    func _emptyArrayLast() {
        printf("Called last() on empty Array\n");
        fatalError();
    }

    func _emptyArrayRemoveFirst() {
        printf("Called removeFirst() on empty Array\n");
        fatalError();
    }

    func _emptyArrayRemoveLast() {
        printf("Called removeLast() on empty Array\n");
        fatalError();
    }
}

func ==<T>(a: ArrayRef<T>, b: ArrayRef<T>) -> bool {
    if (a.size() != b.size()) {
        return false;
    }

    for (let i in 0..a.size()) {
        if (*a[i] != *b[i]) {
            return false;
        }
    }

    return true;
}
